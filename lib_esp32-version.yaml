# lib_esp32-version.yaml — Sensores, botones, LED de estado y chequeo periódico (ESP32/ESP32-C3)
# Uso: packages: internos_esp32: !include lib_esp32-version.yaml
# Requiere: friendly_name; config base con debug: para motivo reinicio. Incluir configuracion_wifi para RSSI.
# --- Resumen LED: 0=apagado (todo bien), 1=fijo (modo AP), 2=intermitente lento (error/temp alta), 3=intermitente rápido (conexión débil/sin WiFi o API) ---

# Constantes (editar aquí o en tu config base; el último que defina gana al mergear):
intervalo_chequeo_esp32: 30s
umbral_temp_alta: 60
umbral_rssi_debil: -80
led_integrado_pin: GPIO2

# --- Eventos a HA (temperatura elevada, conexión débil, etc.) ---
event:
  - platform: template
    name: "${friendly_name} Aviso estado ESP32"
    id: aviso_estado_esp32
    event_types:
      - temperatura_elevada
      - conexion_debil
      - sin_wifi
      - sin_api
      - modo_ap

# --- Intervalos: chequeo de estado y actualización del LED ---
interval:
  - interval: ${intervalo_chequeo_esp32}
    then:
      - script.execute: chequeo_esp32
  - interval: 250ms
    then:
      - script.execute: actualizar_led

# --- Globals: estado del LED (0=apagado todo bien, 1=fijo modo AP, 2=intermitente lento error, 3=intermitente rápido problemas) ---
globals:
  - id: estado_led
    type: int
    restore_value: false
    initial_value: "0"
  - id: led_tick
    type: int
    restore_value: false
    initial_value: "0"
  - id: aviso_temp_ya_enviado
    type: bool
    restore_value: false
    initial_value: "false"
  - id: aviso_rssi_ya_enviado
    type: bool
    restore_value: false
    initial_value: "false"

script:
  - id: chequeo_esp32
    mode: single
    then:
      # Decidir estado_led y enviar eventos a HA (solo al cambiar)
      - if:
          condition: wifi.ap_active
          then:
            - lambda: "id(estado_led) = 1;"
      - else:
          - if:
              condition:
                - wifi.connected
                - api.connected
              then:
                - if:
                    condition:
                      lambda: "return id(internal_temp).state > ${umbral_temp_alta};"
                    then:
                      - lambda: "id(estado_led) = 2;"
                      - if:
                          condition: lambda: "return !id(aviso_temp_ya_enviado);"
                          then:
                            - lambda: "id(aviso_temp_ya_enviado) = true;"
                            - event.trigger:
                                id: aviso_estado_esp32
                                event_type: temperatura_elevada
                    else:
                      - lambda: "id(aviso_temp_ya_enviado) = false;"
                      - if:
                          condition:
                            lambda: "return id(wifi_rssi).state < ${umbral_rssi_debil};"
                          then:
                            - lambda: "id(estado_led) = 3;"
                            - if:
                                condition: lambda: "return !id(aviso_rssi_ya_enviado);"
                                then:
                                  - lambda: "id(aviso_rssi_ya_enviado) = true;"
                                  - event.trigger:
                                      id: aviso_estado_esp32
                                      event_type: conexion_debil
                          else:
                            - lambda: "id(aviso_rssi_ya_enviado) = false;"
                            - lambda: "id(estado_led) = 0;"
              else:
                - lambda: "id(estado_led) = 3;"
                - lambda: "id(aviso_temp_ya_enviado) = false;"
                - lambda: "id(aviso_rssi_ya_enviado) = false;"

  - id: actualizar_led
    mode: single
    then:
      - lambda: "id(led_tick)++;"
      - if:
          condition: lambda: "return id(estado_led) == 0;"
          then:
            - output.turn_off: led_estado
      - else:
          - if:
              condition: lambda: "return id(estado_led) == 1;"
              then:
                - output.turn_on: led_estado
              else:
                - if:
                    condition: lambda: "return id(estado_led) == 2;"
                    then:
                      - if:
                          condition: lambda: "return (id(led_tick) % 4) == 0;"
                          then:
                            - output.toggle: led_estado
                    else:
                      - if:
                          condition: lambda: "return (id(led_tick) % 2) == 0;"
                          then:
                            - output.toggle: led_estado

# --- LED integrado y alarma opcional ---
output:
  - platform: gpio
    pin: ${led_integrado_pin}
    id: led_estado
  # Opcional alarma: descomenta y asigna pin; luego en script actualizar_led duplica cada
  # output.turn_on / turn_off / toggle añadiendo la misma acción con id: alarma_led
  # - platform: gpio
  #   pin: GPIO3
  #   id: alarma_led

# --- Sensores internos ---
sensor:
  - platform: uptime
    name: "${friendly_name} Uptime"
    id: uptime_s
    unit_of_measurement: "s"
    accuracy_decimals: 0
  - platform: internal_temperature
    name: "${friendly_name} Temperatura Interna"
    id: internal_temp
    update_interval: 60s

# --- Motivo último reinicio (requiere debug: en config base) ---
text_sensor:
  - platform: version
    name: "${friendly_name} Versión ESPHome"
    hide_timestamp: true
  - platform: debug
    reset_reason:
      name: "${friendly_name} Motivo último reinicio"

# --- Deep sleep ---
deep_sleep:
  id: deep_sleep
  run_duration: 0s
  sleep_duration: 24h

# --- Botones ---
button:
  - platform: restart
    name: "${friendly_name} Reiniciar dispositivo"
  - platform: safe_mode
    name: "${friendly_name} Reiniciar en modo seguro"
  - platform: factory_reset
    name: "${friendly_name} Restablecer a fábrica"
  - platform: template
    name: "${friendly_name} Apagar (deep sleep)"
    icon: "mdi:power"
    on_press:
      then:
        - deep_sleep.enter: deep_sleep

  - platform: template
    name: "${friendly_name} Borrar credenciales WiFi"
    icon: "mdi:wifi-cancel"
    on_press:
      then:
        - lambda: "wifi::global_wifi_component->forget();"

