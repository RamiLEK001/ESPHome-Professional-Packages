# =============================================================================
# 游뚿 SUBSISTEMA DE ALARMAS Y TELEMETR칈A AVANZADA
# =============================================================================
# Descripci칩n:
#   Monitoriza silenciosamente la salud f칤sica (RAM, Temp, CPU) y l칩gica (WiFi, API)
#   del chip. Asigna gravedades din치micas y empuja notificaciones Push a tu m칩vil
#   si hay peligro inminente de cuelgue o p칠rdida permanente de conexi칩n.
# =============================================================================

# --- NIVELES DE GRAVEDAD DE ALARMAS ---
# 0: Nada      (Sistema sano 100%)
# 1: Leve      (Cosas informativas, ca칤das de rendimiento, sin acci칩n inmediata)
# 2: Moderado  (Peligro a medio plazo: calentamiento, WiFi perdi칠ndose, RAM fragmentada)
# 3: Grave     (Peligro inminente: Sin WiFi prolongado, Hardware cr칤tico, Cuelgue API)

# =========================================================================================
# CONFIGURA AQU칈: UMBRALES DE HARDWARE Y METAS POR DEFECTO
# =========================================================================================
substitutions:
  # -> CONFIGURA AQU칈: A d칩nde lanzar las alertas Push (ej: notify.notify, notify.mobile_app_iphone)
  ha_notify_service: "notify.notify"

  # -> CONFIGURA AQU칈: Umbrales donde el chip empieza a quejarse
  umbral_wifi_critico_pct: "30.0"      # % de calidad WiFi donde empieza a cortar paquetes (Gravedad 2)
  umbral_wifi_debil_pct: "50.0"        # % de calidad WiFi donde la red va lenta (Gravedad 1)
  umbral_temp_critica: "80.0"          # 춿C Temperatura donde el silicio sufre (Gravedad 3) - ESP32 ONLY
  umbral_temp_elevada: "65.0"          # 춿C Temperatura l칤mite normal (Gravedad 2) - ESP32 ONLY
  umbral_uptime_max: "604800.0"        # Segundos sugeridos para auto-reiniciar y limpiar cach칠s (7 d칤as)(Gravedad 1)


interval:
  - interval: 29s
    then:
      - script.execute: script_alarmas

globals:
  # Nivel de gravedad global (0: Nada, 1: Leve, 2: Moderado, 3: Grave)
  - id: global_gravedad_alarma
    type: int
    restore_value: no
    initial_value: '0'
  
  # Texto que acumula las alarmas activas
  - id: global_texto_alarmas
    type: std::string
    restore_value: no
    initial_value: '""'

# =============================================================================
# --- ESTADOS ---
# =============================================================================

# -----------------------------------------------------------------------------
# BINARY SENSORS 
# -----------------------------------------------------------------------------
binary_sensor:
  # Indica si el dispositivo est치 conectado exitosamente a Home Assistant
  - platform: status
    name: "Estado HA"
    id: status_ha
    entity_category: "diagnostic"

  # Se activa (ON) si la placa ha perdido totalmente la conexi칩n con el router WiFi
  - platform: template
    name: "Modo sin conexi칩n"
    id: modo_sin_conexion
    internal: true
    entity_category: "diagnostic"
    device_class: connectivity
    lambda: "return !id(estado_wifi_activo);"

  # Se activa (ON) si la placa no encontr칩 WiFi y est치 emitiendo su propia red de rescate
  - platform: template
    name: "Modo AP"
    id: modo_ap
    internal: true
    entity_category: "diagnostic"
    device_class: connectivity
    lambda: "return id(estado_ap_activo);"

  # Se activa (ON) cuando la API nativa de ESPHome logra comunicarse con Home Assistant
  - platform: template
    name: "API conectada"
    id: api_conectada
    internal: true
    entity_category: "diagnostic"
    device_class: connectivity
    lambda: "return id(estado_api_activa);"

# -----------------------------------------------------------------------------
# SENSORS
# -----------------------------------------------------------------------------
sensor:
  # --- 1. Red y WiFi ---
  # Fuerza de la se침al WiFi bruta en decibelios. Oculto por defecto en la interfaz (internal: true)
  - platform: wifi_signal
    name: "Se침al WiFi (dBm)"
    id: wifi_rssi
    update_interval: 60s
    entity_category: "diagnostic"
    internal: true

  # Convierte matem치ticamente los dBm a un porcentaje (0% a 100%) m치s amigable para el usuario
  - platform: copy
    source_id: wifi_rssi
    name: "Se침al WiFi (%)"
    id: wifi_signal_percent
    unit_of_measurement: "%"
    accuracy_decimals: 0
    entity_category: "diagnostic"
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);

  # --- 2. Recursos de Hardware ---
  # Segundos puros desde el arranque. Usado internamente por el motor de alarmas para c치lculos (internal: true)
  - platform: uptime
    name: "Uptime"
    id: uptime_s
    unit_of_measurement: "s"
    accuracy_decimals: 0
    entity_category: "diagnostic"
    internal: true

  # Temperatura del n칰cleo de silicio del chip ESP32 (No disponible en ESP8266)
  # 丘멆잺 ESP8266: Comenta o borra todo este bloque (de la l칤nea 124 a la 129) si usas un ESP8266, o dar치 error de compilaci칩n.
  - platform: internal_temperature
    name: "Temperatura Interna"
    id: internal_temp
    update_interval: 60s
    entity_category: "diagnostic"

  - platform: debug
    # Velocidad del procesador. Sirve para detectar si la placa se queda bloqueada al m치ximo rendimiento
    cpu_frequency:
      name: "Frecuencia CPU"
      id: debug_cpu_freq
      entity_category: "diagnostic"
    # RAM disponible. Vital para asegurar que la placa no sufra un OutOfMemory y crashee
    free:
      name: "RAM Libre"
      id: debug_ram
      entity_category: "diagnostic"
    # Bloque m치ximo de RAM contigua.
    block:
      name: "Bloque M치x RAM"
      id: debug_block
      entity_category: "diagnostic"
    # Tiempo m치ximo que tarda en dar una vuelta el c칩digo.
    loop_time:
      name: "Tiempo de Loop M치ximo"
      id: debug_loop
      entity_category: "diagnostic"
    # M칤nima RAM libre hist칩rica desde el arranque. 칔til para detectar fugas de memoria (Memory Leaks).
    # 丘멆잺 ESP8266: Comenta o borra este bloque 'min_free' (solo ESP32 / LibreTiny)
    min_free:
      name: "RAM Libre M칤nima"
      id: debug_min_free
      entity_category: "diagnostic"
    # Nivel de fragmentaci칩n de la memoria RAM (0% es limpio, >50% puede fallar reservando memoria).
    fragmentation:
      name: "RAM Fragmentaci칩n"
      id: debug_fragmentation
      entity_category: "diagnostic"
    # RAM Externa libre (Solo aplicable en chips ESP32 espec칤ficos con hardware adicional, ej: WROVER).
    # 丘멆잺 Descomenta este bloque SOLO si descomentaste 'psram:' en tu archivo configuracion_base.
    # psram:
    #   name: "PSRAM Libre"
    #   id: debug_psram
    #   entity_category: "diagnostic"

# -----------------------------------------------------------------------------
# TEXT SENSORS (Informaci칩n y Telemetr칤a Textual)
# -----------------------------------------------------------------------------
text_sensor:
  # --- 1. Informaci칩n de Conectividad y Red ---
  # Resumen legible del estado ("Modo AP", "Sin conexi칩n", "No API", "Conectado")
  - platform: template
    name: "Estado conexi칩n"
    id: estado_conexion
    entity_category: "diagnostic"
    update_interval: 15s
    lambda: |-
      if (id(estado_ap_activo)) return {"Modo AP"};
      if (!id(estado_wifi_activo)) return {"Sin conexi칩n"};
      if (!id(estado_api_activa)) return {"No API"};
      return {"Conectado"};

  # Informaci칩n f칤sica del chip en la red de tu casa
  - platform: wifi_info
    ip_address:
      name: "IP actual"
      entity_category: "diagnostic"
    ssid:
      name: "AP SSID"
      entity_category: "diagnostic"
    bssid:
      name: "MAC del AP"
      entity_category: "diagnostic"
    mac_address:
      name: "MAC"
      entity_category: "diagnostic"

  # --- 2. Informaci칩n del Sistema y Compilaci칩n ---
  # Muestra la versi칩n del framework base (Ej: 2024.2.1)
  - platform: version
    name: "Versi칩n ESPHome"
    hide_timestamp: true
    entity_category: "diagnostic"

  # Uptime convertido de Segundos puros a texto humano ("1d 5h 30m 10s")
  - platform: template
    name: "Tiempo de Actividad"
    icon: "mdi:clock-outline"
    entity_category: "diagnostic"
    internal: false
    update_interval: 60s
    lambda: |-
      int seconds = id(uptime_s).state;
      int days = seconds / (24 * 3600);
      seconds = seconds % (24 * 3600);
      int hours = seconds / 3600;
      seconds = seconds % 3600;
      int minutes = seconds / 60;
      int secs = seconds % 60;
      
      return {(
        (days > 0 ? to_string(days) + "d " : "") +
        (hours > 0 ? to_string(hours) + "h " : "") +
        (minutes > 0 ? to_string(minutes) + "m " : "") +
        (to_string(secs) + "s")
      ).c_str()};

  - platform: debug
    # Expone f칤sicamente la 칰ltima causa de reinicio ("Power On", "Software Reset", "Brownout", etc) de forma legible
    reset_reason:
      name: "Motivo 칰ltimo reinicio"
      id: debug_reset_reason
      entity_category: "diagnostic"
    # Exposici칩n alt칤sima de telemetr칤a de sistema: Free heap size al inicio, caracter칤sticas f칤sicas del chip embebido...
    device:
      name: "Informaci칩n Dispositivo"
      entity_category: "diagnostic"


  # Versi칩n del proyecto + Fecha y Hora exacta en la que se flashe칩 la placa
  - platform: template
    name: "ESPHome Project Version Detailed"
    id: esphome_project_version_text_detailed
    icon: "mdi:information-box"
    entity_category: "diagnostic"
    update_interval: 60s
    lambda: |-
      char buffer[26];
      App.get_build_time_string(buffer);
      return { std::string(ESPHOME_PROJECT_VERSION) + " " + std::string(buffer) };

  # Nombre de sistema base
  - platform: template
    name: "ESPHome Project Name"
    id: esphome_project_name
    icon: "mdi:information-box"
    entity_category: "diagnostic"
    update_interval: 60s
    lambda: |-
      return { ESPHOME_PROJECT_NAME };

  # --- 3. Telemetr칤a de Alarmas ---
  # Texto en Home Assistant donde el cerebro avisa ("Nada", "Leve", "Moderado", "Grave")
  - platform: template
    name: "Estado de Gravedad"
    id: sensor_gravedad_texto
    entity_category: "diagnostic"
    icon: "mdi:alert"
    update_interval: never

  # Sensor de texto que expone las alarmas en Home Assistant (Actualizado desde el script)
  - platform: template
    name: "Alarmas Activas"
    id: sensor_texto_alarmas
    entity_category: "diagnostic"
    icon: "mdi:alert-circle"

# -----------------------------------------------------------------------------
# BOTONES Y DEEP SLEEP
# -----------------------------------------------------------------------------
# Motor para dormir la placa para ahorro de energ칤a m치ximo
deep_sleep:
  id: modo_deep_sleep
  sleep_duration: 24h

button:
  # Duerme la placa forzosamente usando el motor deep_sleep configurado arriba
  - platform: template
    name: "Apagar (deep sleep)"
    entity_category: "config"
    icon: "mdi:power"
    on_press:
      then:
        - deep_sleep.enter: modo_deep_sleep
  # Reinicia la placa apag치ndola y volvi칠ndola a encender limpia
  - platform: restart
    id: boton_reinicio
    name: "Reiniciar dispositivo"
    entity_category: "config"
  # Reinicia la placa sin encender integraciones pesadas para protegerla de boot-loops
  - platform: safe_mode
    name: "Reiniciar en modo seguro"
    entity_category: "diagnostic"
  # Borra todo rastro del WiFi y credenciales de la memoria 
  - platform: factory_reset
    name: "Restablecer a f치brica"
    entity_category: "config"

# =============================================================================
# --- MOTOR PRINCIPAL DE ALARMAS ---
# =============================================================================

# -----------------------------------------------------------------------------
# SCRIPTS Y TAREAS PROGRAMADAS
# -----------------------------------------------------------------------------
script:
  - id: script_alarmas
    mode: single
    then:
      - lambda: |-
          std::string alarmas = "";
          int gravedad_max = 0;

          // ==========================================
          // 1. EVALUACI칍N DE ESTADO DE RED
          // ==========================================
          if (!id(estado_wifi_activo)) {
            if (!id(wifi_provisioned)) {
              alarmas += "Esperando Config. Inicial, ";
              // No elevamos gravedad_max para no interferir con el parpadeo del Improv BLE
            } else {
              alarmas += "WiFi Desconectado, ";
              if (gravedad_max < 3) gravedad_max = 3; // Grave
            }
          } else if (id(estado_ap_activo)) {
            alarmas += "Modo AP Emergencia, ";
            if (gravedad_max < 3) gravedad_max = 3; // Grave
          } else if (!id(estado_api_activa)) {
            alarmas += "API Ca칤da, ";
            if (gravedad_max < 3) gravedad_max = 3; // Grave
          } else if (id(wifi_signal_percent).has_state()) {
            if (id(wifi_signal_percent).state < ${umbral_wifi_critico_pct}) {
              alarmas += "Se침al WiFi Cr칤tica, ";
              if (gravedad_max < 2) gravedad_max = 2; // Moderado
            } else if (id(wifi_signal_percent).state < ${umbral_wifi_debil_pct}) {
              alarmas += "Se침al WiFi D칠bil, ";
              if (gravedad_max < 1) gravedad_max = 1; // Leve
            }
          }

          // ==========================================
          // 2. EVALUACI칍N DE HARDWARE Y SISTEMA
          // ==========================================
          
          // A. Temperatura Interna (Usa #ifdef porque ESP8266 interrumpe el parsing)
          #ifdef USE_ESP32
          if (id(internal_temp).has_state()) {
            if (id(internal_temp).state > ${umbral_temp_critica}) {
              alarmas += "Temp Cr칤tica, ";
              if (gravedad_max < 3) gravedad_max = 3;
            } else if (id(internal_temp).state > ${umbral_temp_elevada}) {
              alarmas += "Temp Elevada, ";
              if (gravedad_max < 1) gravedad_max = 2;
            }
          }
          #endif

          // B. Uptime (Reiniciar cada 7 d칤as = 604800s)
          if (id(uptime_s).has_state()) {
            if (id(uptime_s).state > ${umbral_uptime_max}) {
              alarmas += "Reboot Sugerido, ";
              if (gravedad_max < 1) gravedad_max = 1;
            }
          }

          // C. Memoria RAM (Usando substitutions variables adaptables al chip)
          if (id(debug_ram).has_state()) {
            if (id(debug_ram).state < ${umbral_ram_grave}) {
              alarmas += "RAM muy baja, ";
              if (gravedad_max < 3) gravedad_max = 3;
            } else if (id(debug_ram).state < ${umbral_ram_moderada}) {
              alarmas += "Falta de Memoria, ";
              if (gravedad_max < 2) gravedad_max = 2;
            }
          }

          // D. Latencia (Loop Time, tambi칠n por substitutions)
          if (id(debug_loop).has_state()) {
            if (id(debug_loop).state > ${umbral_loop_time}) {
              alarmas += "CPU Lenta / Loop Alto, ";
              if (gravedad_max < 1) gravedad_max = 1;
            }
          }

          // E. Motivo del 칔ltimo Reinicio (String logic & WDT tolerance on 8266)
          if (id(debug_reset_reason).has_state()) {
            std::string rr = id(debug_reset_reason).state;
            // Filtramos razones normales
            if (rr != "Power On" && rr != "Power-on reset" && rr != "Software reset CPU" && rr != "Vbat power on reset" && rr != "USB peripheral") {
              #ifdef USE_ESP8266
              // En ESP8266 "Software WDT reset" es muy natural/habitual
              if (rr != "Software WDT reset") {
                alarmas += "Reinicio por Error, ";
                if (gravedad_max < 2) gravedad_max = 2;
              }
              #else
              alarmas += "Reinicio por Error, ";
              if (gravedad_max < 2) gravedad_max = 2;
              #endif
            }
          }

          // ==========================================
          // 2. PROCESAMIENTO FORMATO DE TEXTO
          // ==========================================
          if (alarmas == "") {
            alarmas = "Ninguna";
            gravedad_max = 0;
          } else {
            // Eliminar la coma extra y el espacio al final (", ")
            alarmas = alarmas.substr(0, alarmas.length() - 2);
          }

          // ==========================================
          // 3. ACTUALIZACI칍N ESTADOS HA Y NOTIFICACIONES
          // ==========================================
          
          // Actualizaci칩n de variables y Sensores (Se ejecuta siempre cada 29s para mantener la gr치fica viva en HA)
          std::string texto_gravedad;
          switch(gravedad_max) {
            case 0: texto_gravedad = "Nada"; break;
            case 1: texto_gravedad = "Leve"; break;
            case 2: texto_gravedad = "Moderado"; break;
            case 3: texto_gravedad = "Grave"; break;
            default: texto_gravedad = "Desconocido"; break;
          }
          
          // Refrescar en Home Assistant
          id(sensor_gravedad_texto).publish_state(texto_gravedad);
          
          // Actualizaci칩n global e impresi칩n de Logs continua (Eliminado el filtro antispam por petici칩n)
          id(global_gravedad_alarma) = gravedad_max;
          
          if (gravedad_max >= 2) {
            ESP_LOGW("alarmas", "Nivel cr칤tico/moderado: %s. Motivos: %s", texto_gravedad.c_str(), alarmas.c_str());
            id(led_estado_sistema).turn_on(); // LED fijo al haber un error importante
          } else if (gravedad_max == 1) {
            ESP_LOGI("alarmas", "Nivel leve: %s. Motivos: %s", texto_gravedad.c_str(), alarmas.c_str());
            id(led_estado_sistema).turn_off();
          } else {
            ESP_LOGI("alarmas", "Sistema OK. Ninguna alarma activa.");
            id(led_estado_sistema).turn_off();
          }

          // Guardar el log interno y publicar en el sensor de texto en HA
          id(global_texto_alarmas) = alarmas;
          id(sensor_texto_alarmas).publish_state(alarmas);
      
      # Enviar notificaci칩n push a Home Assistant cada 29s si hay alarmas Graves(3) o Moderadas(2)
      - if:
          condition:
            lambda: 'return id(global_gravedad_alarma) >= 2;'
          then:
            - homeassistant.service:
                service: ${ha_notify_service}
                data:
                  title: "丘멆잺 Alarma en Dispositivo: ${friendly_name}"
                  message: !lambda 'return id(global_texto_alarmas).c_str();'

